<?php

declare(strict_types=1);

namespace peels\disc;

use peels\disc\disc\File;
use peels\disc\disc\Directory;
use peels\disc\exceptions\DiscException;
use peels\disc\exceptions\FileException;

/**
 * File System Functions
 *
 * File System Abstraction which automatically
 * works in a given root path
 *
 * Can be added with composer by adding a composer.json file with:
 *
 *"autoload": {
 *   "files": ["src/Disc.php"]
 * }
 */
class Disc
{
    public const ALL = 3;
    public const NONE = 0;

    public const TYPE = 1;
    public const PERMISSION = 2;

    public const FILE = 4;
    public const FOLDER = 5;

    protected static $rootPath = '';
    protected static $rootLength = 0;
    protected static $autoGenerateDirectories = true;

    public static function configure(array $configDisc)
    {
        $root = $configDisc['root'] ?? __ROOT__;
        $chdir = $configDisc['chdir'] ?? true;

        self::root($root, $chdir);
    }

    /**
     * set application root directory
     * and change directory into it
     */
    public static function root(string $path, bool $chdir = true): void
    {
        /* Returns canonicalized absolute pathname */
        $realpath = \realpath($path);

        if (!$realpath) {
            throw new DiscException('"' . $path . '" is not a valid directory.');
        }

        /* save it */
        self::$rootPath = $realpath;

        /* calculate it once here */
        self::$rootLength = \strlen($realpath);

        /* change directory to it */
        if ($chdir) {
            \chdir(self::$rootPath);
        }

        /* default true they can change it to false if they need to with the autoGenerateDirectories function */
        self::autoGenerateDirectories(true);
    }

    /**
     * Return the root directory
     */
    public static function getRoot(): string
    {
        return self::$rootPath;
    }

    /**
     * set wether to auto create missing directories
     */
    public static function autoGenerateDirectories(bool $bool = true): void
    {
        self::$autoGenerateDirectories = $bool;
    }

    /**
     * Format a given path so it's based on the applications root directory __ROOT__.
     *
     * Either add or remove __ROOT__ from path
     */
    public static function resolve(string $path, bool $remove = false, int $requiredType = self::NONE): string
    {
        if (empty(self::$rootPath)) {
            throw new DiscException(__METHOD__ . ' root path is not defined. Use Disc::root(...).');
        }

        /* strip it if root path is already present */
        $path = (\substr($path, 0, self::$rootLength) == self::$rootPath) ? \substr($path, self::$rootLength) : $path;

        $short = DIRECTORY_SEPARATOR . \trim($path, DIRECTORY_SEPARATOR);
        $long = self::$rootPath . $short;

        switch ($requiredType) {
            case self::FILE:
                if (!file_exists($long) && !is_file($long)) {
                    throw new DiscException('No such file. ' . $short);
                }
                break;
            case self::FOLDER:
                if (!file_exists($long) && !is_dir($long)) {
                    throw new DiscException('No such directory. ' . $short);
                }
                break;
            default:
                // no check
        }

        /* now resolve - stripped or added? */
        return ($remove) ? $short : $long;
    }

    /**
     * get the WWW path of a file
     */
    public static function resolveWWW(string $path, int $requiredType = self::NONE): string
    {
        if (!defined('__WWW__')) {
            throw new DiscException('__WWW___ is not defined.');
        }

        // resolve off of root first
        $path = self::resolve($path, false, $requiredType);

        $wwwLen = strlen(__WWW__);

        // strip WWW prefix
        // for safety do not to expose a NON www path
        return (substr($path, 0, $wwwLen) == __WWW__) ? substr($path, $wwwLen) : 'Could not build WWW path.';
    }

    public static function stripRootPath(string $files, bool $remove = true)
    {
        return self::resolve($files, $remove);
    }

    public static function stripRootPaths(array $files, bool $remove = true)
    {
        foreach ($files as $index => $file) {
            $files[$index] = self::resolve($file, $remove);
        }

        return $files;
    }

    public static function autoGenMissingDirectory(string $filePath): bool
    {
        return (self::$autoGenerateDirectories) ? (new Directory(dirname(self::resolve($filePath))))->create() : true;
    }

    public static function exists(string $path): bool
    {
        return \file_exists(self::resolve($path));
    }

    public static function require(string $requiredPath) /* mixed|bool */
    {
        return require self::resolve($requiredPath, false, self::FILE);
    }

    public static function requireOnce(string $requiredPath) /* mixed|bool */
    {
        return require_once self::resolve($requiredPath, false, self::FILE);
    }

    public static function include(string $requiredPath) /* mixed|bool */
    {
        return include self::resolve($requiredPath, false, self::FILE);
    }

    public static function includeOnce(string $requiredPath) /* mixed|bool */
    {
        return include_once self::resolve($requiredPath, false, self::FILE);
    }

    /* generators */

    public static function directory(string $path, bool $required = false): Directory
    {
        $path = self::resolve($path);

        if (is_file($path)) {
            throw new DiscException(self::resolve($path, true) . ' is a File.');
        }

        if ($required && !file_exists($path)) {
            throw new DiscException(self::resolve($path, true) . ' does not exist.');
        }

        return new Directory($path);
    }

    public static function file(string $path, bool $required = false): File
    {
        $path = self::resolve($path);

        if (is_dir($path)) {
            throw new DiscException(self::resolve($path, true) . ' is a Directory.');
        }

        if ($required && !file_exists($path)) {
            throw new DiscException(self::resolve($path, true) . ' does not exist.');
        }

        return new File($path);
    }

    /**
     *
     * @param array $files ie. $_FILES
     * @param string $destinationDirectory '/var/uploads'
     * @param int $flushDays 3 (days to leave stuff in destinationDirectory if not moved)
     * @return array array of moved files and other details
     * @throws DiscException
     * @throws FileException
     */
    public static function uploads(array $files, string $destinationDirectory, int $flushDays = 0): array
    {
        $uploadErrorText = [
            UPLOAD_ERR_OK => 'There is no error, the file uploaded with success.',
            UPLOAD_ERR_INI_SIZE => 'The uploaded file exceeds the upload_max_filesize directive in php.ini.',
            UPLOAD_ERR_FORM_SIZE => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.',
            UPLOAD_ERR_PARTIAL => 'The uploaded file was only partially uploaded.',
            UPLOAD_ERR_NO_FILE => 'No file was uploaded.',
            UPLOAD_ERR_NO_TMP_DIR => 'Missing a temporary directory.',
            UPLOAD_ERR_CANT_WRITE => 'Cannot write to target directory. Please fix CHMOD.',
            UPLOAD_ERR_EXTENSION => 'A PHP extension stopped the file upload.',
            66 => 'Cannot move file',
        ];

        $destinationDirectory = self::directory($destinationDirectory);

        $destinationDirectory->clean($flushDays);

        // array of upload files
        $uploads = [];

        // get us a text based directory path
        $subDestinationDirectory = $destinationDirectory->getPath() . DIRECTORY_SEPARATOR . substr(sha1(uniqid()), 0, 6);

        foreach ($files as $file) {
            $file = (object)$file;

            // We can really only trust and use 3 things:
            // temp file path set by PHP
            // The name "passed" by user (which we immediately clean because there is no point working with a name we are ultimately going to clean anyway)
            // If there is an error or not set by PHP
            if (!isset($file->tmp_name, $file->name, $file->error)) {
                throw new FileException('Upload file missing a required property. The keys tmp_name, name, error are required.');
            }

            // PHP reports no error
            if ($file->error === 0) {
                // move for further processing into a temp directory
                $destinationFile = $subDestinationDirectory . DIRECTORY_SEPARATOR . self::cleanFilename($file->name);

                if (!is_dir($subDestinationDirectory)) {
                    mkdir($subDestinationDirectory, 0777, true);
                }

                if (is_uploaded_file($file->tmp_name)) {
                    $file->error = move_uploaded_file($file->tmp_name, $destinationFile) ? 0 : 66;
                } else {
                    $file->error = rename($file->tmp_name, $destinationFile) ? 0 : 66;
                }
            }

            // Did processing the file give us an error?
            if ($file->error === 0) {
                $file = new File($destinationFile);
            } else {
                $file->hasError = true;
                $file->errorMsg = $uploadErrorText[$file->error] ?? 'Unknown Error.';
            }

            $uploads[] = $file;
        }

        // return uploaded files
        return $uploads;
    }

    /* formatters */

    public static function formatSize(int $bytes): string
    {
        $i = floor(log($bytes, 1024));

        return round($bytes / pow(1024, $i), [0, 1, 2, 2, 3][$i]) . ['B', 'kB', 'MB', 'GB', 'TB'][$i];
    }

    /**
     * Method formatTime
     */
    public static function formatTime(?int $timestamp, ?string $dateFormat = null): int|string
    {
        return ($timestamp !== null && $dateFormat !== null) ? date($dateFormat, $timestamp) : $timestamp;
    }

    public static function formatMode(int $mode, int $option = Disc::ALL): string
    {
        $info = '';

        // self::TYPE
        if (1 & $option) {
            $info .= self::formatType($mode);
        }

        // self::PERMISSION
        if (2 & $option) {
            $info .= self::formatPermission($mode);
        }

        return $info;
    }

    public static function formatType(int $mode): string
    {
        $info = '';

        switch ($mode & 0xF000) {
                // socket
            case 0xC000:
                $info = 's';
                break;
                // symbolic link
            case 0xA000:
                $info = 'l';
                break;
                // regular
            case 0x8000:
                $info = 'r';
                break;
                // block special
            case 0x6000:
                $info = 'b';
                break;
                // directory
            case 0x4000:
                $info = 'd';
                break;
                // character special
            case 0x2000:
                $info = 'c';
                break;
                // FIFO pipe
            case 0x1000:
                $info = 'p';
                break;
                // unknown
            default:
                $info = 'u';
        }
        return $info;
    }

    public static function formatPermission(int $mode): string
    {
        $info = '';

        // Owner
        $info .= ($mode & 0x0100) ? 'r' : '-';
        $info .= ($mode & 0x0080) ? 'w' : '-';

        $a = ($mode & 0x0800) ? 's' : 'x';
        $b = ($mode & 0x0800) ? 'S' : '-';

        $info .= ($mode & 0x0040) ? $a : $b;

        // Group
        $info .= ($mode & 0x0020) ? 'r' : '-';
        $info .= ($mode & 0x0010) ? 'w' : '-';

        $a = ($mode & 0x0400) ? 's' : 'x';
        $b = ($mode & 0x0400) ? 'S' : '-';

        $info .= ($mode & 0x0008) ? $a : $b;

        // World
        $info .= ($mode & 0x0004) ? 'r' : '-';
        $info .= ($mode & 0x0002) ? 'w' : '-';

        $a = ($mode & 0x0200) ? 't' : 'x';
        $b = ($mode & 0x0200) ? 'T' : '-';

        $info .= ($mode & 0x0001) ? $a : $b;

        return $info;
    }

    public static function cleanFilename(string $filename): string
    {
        $nonDisplayables = '/[\x00-\x1F\x7F-\xFFFF]+/S';   // 00-31, 127-65535

        do {
            $filename = preg_replace($nonDisplayables, '', $filename, -1, $count);
        } while ($count);

        $bad = [
            '../', '<!--', '-->',
            "'", '"', '&', '$', '#',
            ';', '?', '%20', '%22',
            '/', '*', ':', '\\',
            '!', '%', '`', '^',
            '%3c',        // <
            '%253c',      // <
            '%3e',        // >
            '%0e',        // >
            '%28',        // (
            '%29',        // )
            '%2528',      // (
            '%26',        // &
            '%24',        // $
            '%3f',        // ?
            '%3b',        // ;
            '%3d'         // =
        ];

        do {
            $old = $filename;
            $filename = str_replace($bad, '', $filename);
        } while ($old !== $filename);

        return $filename;
    }

    /* copy, rename, delete, move files and directories */

    public static function copy(File|Directory $source, File|Directory $destination): bool
    {
        $success = false;

        if ($source->isDir()) {
            // directory
            $success = self::copyRecursive($source->getPathname(), $destination->getPathname());
        } else {
            // file
            if ($destination->isDir()) {
                $destinationPath = $destination->getPathname() . DIRECTORY_SEPARATOR . $source->getFilename();
            } else {
                $destinationPath = $destination->getPathname();
            }

            $success = \copy($source->getPathname(), $destinationPath);
        }

        return $success;
    }

    public static function delete(File|Directory $source): bool
    {
        $success = false;

        $path = $source->getPathname();

        if (!file_exists($path)) {
            throw new DiscException('Could not locate "' . $path . '".');
        }

        if ($source->isDir()) {
            $success = self::removeRecursive($source->getPathname(), true);
        } else {
            $success = unlink($source->getPathname());
        }

        return $success;
    }

    public static function deleteContent(Directory $source): bool
    {
        $path = $source->getPathname();

        if (!file_exists($path)) {
            throw new DiscException('Could not locate "' . $path . '".');
        }

        return self::removeRecursive($path, false);
    }

    public static function move(File|Directory $source, File|Directory $destination): bool
    {
        return \rename($source->getPathname(), $destination->getPathname());
    }

    public static function rename(File|Directory $source, string $newName): File|Directory
    {
        $path = $source->getPathname();

        if (!file_exists($path)) {
            throw new DiscException('Could not locate "' . $path . '".');
        }

        if (strpos($newName, '/', 0) !== false) {
            throw new DiscException('Destination should not be a path');
        }

        $newPath = dirname($path) . DIRECTORY_SEPARATOR . $newName;

        if (rename($path, $newPath)) {
            if (is_dir($newPath)) {
                $destination = new Directory($newPath);
            } else {
                $destination = new File($newPath);
            }
        } else {
            throw new DiscException('Could not rename "' . $path . '" to "' . $newName . '".');
        }

        return $destination;
    }

    /* internal */

    protected static function removeRecursive(string $path, bool $removeDirectory = true): bool
    {
        $files = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::CHILD_FIRST);

        foreach ($files as $fileinfo) {
            if ($fileinfo->isDir()) {
                self::removeRecursive($fileinfo->getPathname());
            } else {
                \unlink($fileinfo->getPathname());
            }
        }

        if ($removeDirectory) {
            \rmdir($path);
        }

        return true;
    }

    protected static function copyRecursive(string $source, string $destination): bool
    {
        $dir = \opendir($source);

        if (!is_dir($destination)) {
            (new Directory($destination))->create();
        }

        while ($file = \readdir($dir)) {
            if (($file != '.') && ($file != '..')) {
                if (\is_dir($source . DIRECTORY_SEPARATOR . $file)) {
                    self::copyRecursive($source . DIRECTORY_SEPARATOR . $file, $destination . DIRECTORY_SEPARATOR . $file);
                } else {
                    \copy($source . DIRECTORY_SEPARATOR . $file, $destination . DIRECTORY_SEPARATOR . $file);
                }
            }
        }

        \closedir($dir);

        return true;
    }
}
