#!/usr/bin/env php
<?php

declare(strict_types=1);

define('__ROOT__', realpath(__DIR__ . '/../../../../'));

$_ENV = array_replace_recursive($_ENV, parse_ini_file(__ROOT__ . '/.env', true, INI_SCANNER_TYPED));

$config = include __ROOT__ . '/config/config.php';

require_once __ROOT__ . '/vendor/autoload.php';

/* send config into application */
$container = \orange\framework\Application::cli($config);

$argc = $_SERVER['argc'];
$argv = $_SERVER['argv'];

echo PHP_EOL;

if ($argc != 2) {
    die('Please provide view directory relative to ' . __ROOT__ . PHP_EOL . PHP_EOL);
}

/**
 * Convert
 * # [route(get,/peopledropdown,peopledropdown)]
 *
 * method(s), url, name (optional)
 * callback auto detected
 *
 * to
 *
 * ['method' => 'get', 'url' => '/peopledropdown', 'callback' => [\application\people\controllers\MainController::class, 'dropdown'], 'name' => 'peopledropdown'],
 */


$path = __ROOT__ . DIRECTORY_SEPARATOR . trim(trim($argv[1]), '/');

if (!$path = realpath($path)) {
    die('Can not locate "' . $path . '"' . PHP_EOL);
}

if (is_dir($path)) {
    $found = [];

    foreach (rglob($path, '*.php') as $filepath) {
        $source = file_get_contents($filepath);

        if ($f = token($source)) {
            $found[$filepath] = $f;
        }
    }
} elseif (is_file($path)) {
    $source = file_get_contents($path);
    $lines = token($source);

    if (!$lines) {
        die('error trying to tokenize "' . $path . '".' . PHP_EOL);
    }

    $found[$path] = $lines;
} else {
    die($path . ' is not a Directory or File.');
}

$entries = [];
$conflicts = [];
$urlConflicts = [];
$nameConflicts = [];

foreach ($found as $filepath => $lines) {
    $controller = substr($filepath, strlen(__ROOT__) + 1, -4);
    $entries[] = '// ' . $controller;

    foreach ($lines as $line) {
        $entry = [];

        $nameKey = 'name: ' . ($line['attr']['name'] ?? hrtime(true));
        $urlKey = ($line['attr']['method'] ?? '') . '->' . ($line['attr']['url'] ?? '');

        if (in_array($urlKey, $urlConflicts)) {
            $conflicts[$urlKey] = $conflicts[$urlKey] ?? 1;
            $conflicts[$urlKey] = $conflicts[$urlKey] + 1;
        }
        $urlConflicts[$urlKey] = $urlKey;

        if (in_array($nameKey, $nameConflicts)) {
            $conflicts[$nameKey] = $conflicts[$nameKey] ?? 1;
            $conflicts[$nameKey] = $conflicts[$nameKey] + 1;
        }
        $nameConflicts[$nameKey] = $nameKey;

        foreach ($line['attr'] as $name => $value) {
            $entry[] = "'" . $name . "' => '" . $value . "'";
        }

        if (isset($line['fullclass'])) {
            $entry[] = "'callback' => [" . $line['fullclass'] . "::class, '" . $line['function'] . "']";
        }

        // now build PHP
        // ['method' => 'get', 'url' => '/people', 'callback' => [\application\people\controllers\MainController::class, 'readList'], 'name' => 'people'],

        $entries[] = '[' . implode(', ', $entry) . '],';
    }

    $entries[] = '// ' . str_repeat('-', strlen($controller)) . PHP_EOL;
}

// ok now let's create some output
echo PHP_EOL . 'Found Files: ' . count($found) . PHP_EOL;
echo PHP_EOL . 'Found Routes:' . PHP_EOL;
echo PHP_EOL . '*** copy & paste as needed ***' . PHP_EOL . PHP_EOL;

echo implode(PHP_EOL, $entries);

echo PHP_EOL . PHP_EOL;

echo PHP_EOL . 'Conflicts: ' . count($conflicts) . PHP_EOL;
foreach ($conflicts as $string => $count) {
    echo $string . ' used ' . $count . ' times' . PHP_EOL;
}
echo PHP_EOL . PHP_EOL;

if (strtolower(readline('Merge? Y/(N)')) == 'y') {
    $routesFile = __ROOT__ . '/config/routes.php';
    if (!file_exists($routesFile)) {
        die('Can not find ' . $routesFile . PHP_EOL);
    }

    $routerContents = file_get_contents($routesFile);

    $find = '/* end merged contents */';
    if (strpos($routerContents, $find) === false) {
        die('Could not find "' . $find . '"' . PHP_EOL);
    }

    $newFile = [];

    foreach (explode(PHP_EOL, $routerContents) as $line) {
        if (strpos($line, $find) !== false) {
            // found the end contents line start merge
            $identSize = strlen(rtrim($line)) - strlen(ltrim($line));

            doMerge($entries, $routerContents, $newFile, str_repeat(' ', $identSize));
        }
        $newFile[] = $line;
    }

    $text = implode(PHP_EOL, $newFile) . PHP_EOL;

    echo $text;

    if (strtolower(readline('Write? Y/(N)')) == 'y') {
        file_put_contents($routesFile, $text);
    }
}

function doMerge(array $entries, string $routerContents, array &$newFile, string $indent): void
{
    foreach ($entries as $entry) {
        if (strpos($routerContents, $entry) === false) {
            $newFile[] = $indent . $entry;
        }
    }
}

function rglob($path = '', $pattern = '*', $flags = 0)
{
    $paths = glob($path . '*', GLOB_MARK | GLOB_ONLYDIR | GLOB_NOSORT);
    $files = glob($path . $pattern, $flags);

    foreach ($paths as $path) {
        $files = array_merge($files, rglob($path, $pattern, $flags));
    }

    return $files;
}

function token(string $source): array|false
{
    $collected = [];
    $tokens = null;
    $namespace = '';
    $classname = '';
    $comment = '';
    $function = '';

    try {
        $tokens = token_get_all($source, TOKEN_PARSE);
    } catch (Throwable $e) {
    }

    if ($tokens) {
        /*
        single character
         - or -
        the token index in element 0
        the string content of the original token in element 1
        the line number in element 2
        */

        foreach ($tokens as $index => $token) {
            if (is_array($token)) {
                switch (token_name($token[0])) {
                    case 'T_NAMESPACE':
                        $namespace = $tokens[$index + 2][1];
                        break;
                    case 'T_CLASS':
                        $classname = $tokens[$index + 2][1];
                        break;
                    case 'T_COMMENT':
                        // these ARE NOT real PHP 8 attrubutes they only "look" like them
                        // comment must start with "# [route("
                        if (substr(strtolower(trim($token[1])), 0, 9) == '# [route(') {
                            if (token_name($tokens[$index + 2][0]) == 'T_PUBLIC') {
                                if (token_name($tokens[$index + 4][0]) == 'T_FUNCTION') {
                                    $comment = $token[1];
                                    $function = $tokens[$index + 6][1];
                                    $attr = splitAttr($comment);

                                    $collected[] = [
                                        'namespace' => $namespace,
                                        'classname' => $classname,
                                        'fullclass' => chr(92) . $namespace . chr(92) . $classname,
                                        'comment' => $comment,
                                        'function' => $function,
                                        'attr' => $attr,
                                    ];
                                }
                            }
                        }
                        break;
                    default:
                        // line number, token name, token id, contents
                        //echo $token[2] . ' ' . token_name($token[0]) . ' [' . $token[0] . '] "' . $token[1] . '"' . PHP_EOL;
                }
            } else {
                //echo $token . PHP_EOL;
            }
        }
    }

    return count($collected) ? $collected : false;
}

function splitAttr(string $comment): array
{
    $comment = trim($comment);

    $x = strpos($comment, '(');

    if ($x) {
        $comment = substr($comment, $x  + 1);
    }

    $x = strrpos($comment, ')');

    if ($x) {
        $comment = substr($comment, 0, $x);
    }

    $args = str_getcsv($comment);

    $return = [];

    if (isset($args[0])) {
        $return['method'] = trim($args[0]);
    }
    if (isset($args[1])) {
        $return['url'] = trim($args[1]);
    }
    if (isset($args[2])) {
        $return['name'] = trim($args[2]);
    }

    return $return;
}
