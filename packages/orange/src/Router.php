<?php

declare(strict_types=1);

namespace orange\framework;

use orange\framework\base\Singleton;
use orange\framework\exceptions\InvalidValue;
use orange\framework\interfaces\InputInterface;
use orange\framework\traits\ConfigurationTrait;
use orange\framework\exceptions\MissingRequired;
use orange\framework\interfaces\RouterInterface;
use orange\framework\exceptions\router\RouteNotFound;
use orange\framework\exceptions\router\RouterNameNotFound;

/**
 * Class Router
 *
 * Manages route definitions, matching requests to routes, and generating URLs from route names.
 * Implements Singleton and RouterInterface patterns.
 *
 * Key Responsibilities:
 * - Adding individual routes or groups of routes.
 * - Matching incoming HTTP requests to defined routes.
 * - Generating URLs based on route names and arguments.
 * - Handling configuration for routing rules and site URLs.
 *
 * @package orange\framework
 */
class Router extends Singleton implements RouterInterface
{
    /** include ConfigurationTrait methods */
    use ConfigurationTrait;

    /**
     * @var InputInterface $input
     * Provides access to input-related utilities (e.g., HTTP method, request URI).
     */
    protected InputInterface $input;

    /**
     * @var string $siteUrl
     * Base URL of the site, used for generating full URLs.
     */
    protected string $siteUrl = '';

    /**
     * @var array $routes
     * List of all registered routes.
     */
    protected array $routes = [];

    /**
     * @var array $matched
     * Stores information about the last matched route.
     */
    protected array $matched = [];

    /**
     * @var bool $getUrlSkip
     * Determines whether URL validation during generation can be skipped.
     */
    protected bool $getUrlSkip = false;

    /**
     * @var string $matchedUrl
     * Stores the URL generated by `getUrl()` method.
     */
    protected string $matchedUrl = '';

    /**
     * Protected constructor to enforce Singleton usage.
     *
     * @param array $config Configuration array for routing settings.
     * @param InputInterface $input Provides request-related data.
     * @throws MissingRequired If the 'site' configuration is missing.
     */
    protected function __construct(array $config, InputInterface $input)
    {
        logMsg('INFO', __METHOD__);

        // load the default configs
        $this->config = $this->mergeWithDefault($config, false, 'routes');

        if (empty($this->config['site'])) {
            throw new MissingRequired('Route config "site" in routes.php can not be empty.');
        }

        $this->input = $input;

        $this->routes = [];

        $this->siteUrl = $this->config['site'];
        $this->getUrlSkip = $this->config['getUrlSkip'];

        $this->addRoutes($this->config['routes']);
        $this->addRoutes($this->config['default routes']);

        $this->matched = [
            'request method' => null,
            'request uri' => null,
            'matched uri' => null,
            'matched method' => null,
            'url' => null,
            'argv' => null,
            'argc' => 0,
            'args' => 0,
            'name' => null,
            'callback' => null,
        ];
    }

    /**
     * Adds a single route definition.
     *
     * @param array $options Route configuration (e.g., method, URL pattern, callback).
     * @return self
     */
    public function addRoute(array $options): self
    {
        logMsg('DEBUG', __METHOD__, $options);

        $this->routes[] = $options;

        return $this;
    }

    /**
     * Adds multiple routes in bulk.
     *
     * @param array $routes Array of route configurations.
     * @return self
     */
    public function addRoutes(array $routes): self
    {
        logMsg('INFO', __METHOD__);
        logMsg('INFO', 'Routes ' . count($routes));

        foreach ($routes as $route) {
            $this->addRoute($route);
        }

        return $this;
    }

    /**
     * Matches a request URI and method to a defined route.
     *
     * @param string $requestUri The request URI to match.
     * @param string $requestMethod The HTTP request method (e.g., GET, POST).
     * @return self
     * @throws RouteNotFound If no matching route is found.
     */
    public function match(string $requestUri, string $requestMethod): self
    {
        logMsg('DEBUG', __METHOD__, ['requestUri' => $requestUri, 'requestMethod' => $requestMethod]);

        $url = false;
        $requestMethod = strtoupper($requestMethod);

        // main loop
        foreach ($this->routes as $route) {
            if (isset($route['method'])) {
                $matchedMethod = (is_array($route['method'])) ? array_map('strtoupper', $route['method']) : [0 => strtoupper($route['method'])];

                // check if the current request method matches and the expression matches
                if ((in_array($requestMethod, $matchedMethod) || $route['method'] == '*') && preg_match("@^" . $route['url'] . "$@D", '/' . trim($requestUri, '/'), $argv)) {
                    // remove the first arg
                    $url = array_shift($argv);

                    // pop out of foreach loop
                    break;
                }
            }
        }

        if (!$url) {
            throw new RouteNotFound('[' . $requestMethod . ']' . $requestUri);
        }

        /* What is returned by getMatched() if no key is provided */
        $this->matched = [
            'request method' => $requestMethod,
            'request uri' => $requestUri,
            'matched uri' => $route['url'],
            'matched method' => $matchedMethod[0],
            'url' => $url,
            'argv' => $argv,
            'argc' => count($argv),
            'args' => (bool)count($argv),
            'name' => $route['name'] ?? null,
            'callback' => $route['callback'] ?? null,
        ];

        logMsg('DEBUG', 'matched', $this->matched);

        return $this;
    }

    /**
     * Retrieves matched route information.
     *
     * @param string|null $key Specific key to retrieve (e.g., 'url', 'method').
     * @return mixed The value of the matched key or all matched data.
     * @throws InvalidValue If an invalid key is requested.
     */
    public function getMatched(string $key = null): mixed /* mixed string|array */
    {
        logMsg('DEBUG', __METHOD__, ['key' => $key]);

        if ($key != null && !\array_key_exists(strtolower($key), $this->matched)) {
            throw new InvalidValue('Unknown routing value "' . $key . '"');
        }

        return ($key) ? $this->matched[strtolower($key)] : $this->matched;
    }

    /**
     * Generates a URL from a named route and arguments.
     *
     * @param string $searchName Route name.
     * @param array $arguments Arguments for dynamic segments.
     * @return string The generated URL.
     * @throws RouterNameNotFound If the route name is not found.
     */
    public function getUrl(string $searchName, array $arguments = []): string
    {
        logMsg('INFO', __METHOD__ . ' ' . $searchName);
        logMsg('DEBUG', '', ['searchName' => $searchName, 'arguments' => $arguments]);

        $this->matchedUrl = '';

        $searchName = $this->normalize($searchName);

        foreach ($this->routes as $record) {
            $matches = [];

            // do we have a name and url? with && if the first test is false the second isn't even tested
            if (isset($record['name'], $record['url']) && $this->normalize($record['name']) == $searchName && preg_match_all('/\((.*?)\)/m', $record['url'], $matches, PREG_SET_ORDER, 0) !== false) {
                $this->matchedUrl = $this->processMatchedUrl($searchName, $arguments, $record['url'], $matches);

                // leave for loop on first solid match
                break;
            }
        }

        // if we are still empty then it's a complete fail
        if (empty($this->matchedUrl)) {
            throw new RouterNameNotFound('url route named "' . $searchName . '" not found');
        }

        logMsg('INFO', __METHOD__ . ' matched Url ' . $this->matchedUrl);

        return $this->matchedUrl;
    }

    /**
     * Generates the site's base URL, optionally with an HTTP/HTTPS prefix.
     *
     * This method allows the caller to:
     * - Include or exclude the HTTP/HTTPS prefix.
     * - Manually specify a custom prefix.
     *
     * @param bool|string $appendHttp
     *      - `true`: Automatically determines `http` or `https` based on the request.
     *      - `false`: Returns only the base URL without any protocol prefix.
     *      - `string`: Allows specifying a custom protocol prefix (e.g., `'ftp://'`).
     *
     * @return string The generated base URL with the specified prefix.
     */
    public function siteUrl(bool|string $appendHttp = true): string
    {
        logMsg('INFO', __METHOD__ . ' ' . $appendHttp);

        $prefix = '';

        if ($appendHttp === true) {
            $s = $this->input->isHttpsRequest() ? 's' : '';
            $prefix = ($appendHttp) ? 'http' . $s . '://' : '';
        } elseif (is_string($appendHttp)) {
            $prefix = $appendHttp;
        }

        $complete = $prefix . $this->siteUrl;

        logMsg('INFO', $complete);

        return $complete;
    }

    /**
     * Processes and generates a matched URL based on route arguments.
     *
     * This method replaces dynamic segments in a route URL with provided arguments,
     * ensuring they match expected patterns.
     *
     * @param string $searchName The name of the route being processed.
     * @param array $arguments An array of arguments to replace dynamic segments in the URL.
     * @param string $matchedUrl The base URL template containing dynamic placeholders.
     * @param array $matches Matches extracted from the URL pattern using regex.
     *
     * @return string The fully resolved and processed URL with arguments injected.
     * @throws InvalidValue If argument count mismatches the placeholders or regex validation fails.
     */
    protected function processMatchedUrl(string $searchName, array $arguments, string $matchedUrl, array $matches): string
    {
        logMsg('INFO', __METHOD__ . ' search ' . $searchName);
        logMsg('DEBUG', '', ['searchName' => $searchName, 'arguments' => $arguments, 'matchedUrl' => $matchedUrl, 'matches' => $matches]);

        $matchesCount = count($matches);

        if (count($arguments) != $matchesCount) {
            throw new InvalidValue('Parameter count mismatch. Expecting ' . $matchesCount . ' got ' . count($arguments) . ' route named "' . $searchName . '".');
        }

        if ($matchesCount > 0) {
            foreach ($matches as $index => $match) {
                $value = (string)$arguments[$index];

                // make sure the argument matches the regular expression for that segement
                if (!$this->getUrlSkip && !preg_match('@' . $match[0] . '@m', $value)) {
                    throw new InvalidValue('Parameter mismatch. Expecting ' . $match[1] . ' got ' . $value . ' route named "' . $searchName . '".');
                }

                // replace the segement with the passed argument
                $matchedUrl = preg_replace('/' . preg_quote($match[0], '/') . '/', $value, $matchedUrl, 1);
            }
        }

        logMsg('INFO', __METHOD__ . ' match ' . $matchedUrl);

        return $matchedUrl;
    }
}
