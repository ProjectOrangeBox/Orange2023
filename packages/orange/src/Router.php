<?php

declare(strict_types=1);

namespace orange\framework;

use orange\framework\base\Singleton;
use orange\framework\exceptions\InvalidValue;
use orange\framework\interfaces\InputInterface;
use orange\framework\traits\ConfigurationTrait;
use orange\framework\exceptions\MissingRequired;
use orange\framework\interfaces\RouterInterface;
use orange\framework\exceptions\router\RouteNotFound;
use orange\framework\exceptions\router\RouterNameNotFound;

/**
 * Class Router
 *
 * Manages route definitions, matching requests to routes, and generating URLs from route names.
 * Implements Singleton and RouterInterface patterns.
 *
 * Key Responsibilities:
 * - Adding individual routes or groups of routes.
 * - Matching incoming HTTP requests to defined routes.
 * - Generating URLs based on route names and arguments.
 * - Handling configuration for routing rules and site URLs.
 *
 * @package orange\framework
 */
class Router extends Singleton implements RouterInterface
{
    /** include ConfigurationTrait methods */
    use ConfigurationTrait;

    /**
     * Provides access to input-related utilities (e.g., HTTP method, request URI).
     */
    protected InputInterface $input;

    /**
     * Base URL of the site, used for generating full URLs.
     */
    protected string $siteUrl = '';

    /**
     * List of all registered routes.
     */
    protected array $routes = [];

    /**
     * Stores information about the last matched route.
     */
    protected array $matched = [];

    /**
     * Determines whether URL validation during generation can be skipped.
     */
    protected bool $getUrlSkip = false;

    /**
     * Stores the URL generated by `getUrl()` method.
     */
    protected string $matchedUrl = '';

    /**
     * Routes array where the route name is the array key for fast searching in getUrl
     */
    protected array $routesByName = [];

    /**
     * Protected constructor to enforce Singleton usage.
     *
     * @param array $config Configuration array for routing settings.
     * @param InputInterface $input Provides request-related data.
     * @throws MissingRequired If the 'site' configuration is missing.
     */
    protected function __construct(array $config, InputInterface $input)
    {
        logMsg('INFO', __METHOD__);

        // load the default configs
        $this->config = $this->mergeWithDefault($config, false, 'routes');

        if (empty($this->config['site'])) {
            throw new MissingRequired('Route config "site" in routes.php can not be empty.');
        }

        $this->input = $input;

        $this->routes = [];

        $this->siteUrl = $this->config['site'];
        $this->getUrlSkip = $this->config['getUrlSkip'];

        // add 404 first which makes it the last in the search
        $this->addRoute($this->config['404']);

        // add our default home - this could get overwritten by another home
        $this->addRoute($this->config['home']);

        // add the user supplied routes
        $this->addRoutes($this->config['routes']);

        // we do very little extra processing when adding routes to keep this quick
        // since this array is built with each page load.
        // This would be an excellent place for caching in production for example

        $this->matched = [
            'request method' => null,
            'request uri' => null,
            'matched uri' => null,
            'matched method' => null,
            'url' => null,
            'argv' => null,
            'argc' => 0,
            'args' => 0,
            'name' => null,
            'callback' => null,
        ];
    }

    /**
     * Adds a single route definition.
     *
     * @param array $options Route configuration (e.g., method, URL pattern, callback).
     * @return self
     */
    public function addRoute(array $options): self
    {
        logMsg('DEBUG', __METHOD__, $options);

        // FILO stack
        array_unshift($this->routes, $options);

        // create our routes by name array for the getUrl search
        // if it doesn't have an name then we just use a bogus record key to keep this quick
        $this->routesByName[$this->normalize($options['name'] ?? UNDEFINED)] = $options;

        return $this;
    }

    /**
     * Adds multiple routes in bulk.
     *
     * @param array $routes Array of route configurations.
     * @return self
     */
    public function addRoutes(array $routes): self
    {
        logMsg('INFO', __METHOD__);
        logMsg('INFO', 'Routes ' . count($routes));

        // put them in the array as seen in the file top to bottom
        foreach (array_reverse($routes) as $route) {
            $this->addRoute($route);
        }

        return $this;
    }

    /**
     * Matches a request URI and method to a defined route.
     *
     * @param string $requestUri The request URI to match.
     * @param string $requestMethod The HTTP request method (e.g., GET, POST).
     * @return self
     * @throws RouteNotFound If no matching route is found.
     */
    public function match(string $requestUri, string $requestMethod): self
    {
        logMsg('DEBUG', __METHOD__, ['requestUri' => $requestUri, 'requestMethod' => $requestMethod]);

        $url = false;
        $argv = [];
        $requestMethodUpperCase = strtoupper($requestMethod);

        // main loop
        foreach ($this->routes as $route) {
            if (isset($route['method'], $route['url'])) {
                $routeMethods = is_array($route['method']) ? array_map('strtoupper', $route['method']) : [0 => strtoupper($route['method'])];

                // check if the current request method matches and the expression matches
                if ((in_array($requestMethodUpperCase, $routeMethods) || $route['method'] == '*') && preg_match("@^" . $route['url'] . "$@D", '/' . trim($requestUri, '/'), $argv)) {
                    // remove the first arg
                    $url = array_shift($argv);

                    // pop out of foreach loop
                    break;
                }
            }
        }

        // did we match a url?
        if (!$url) {
            throw new RouteNotFound('[' . $requestMethod . ']' . $requestUri);
        }

        $this->matched = [
            'request method' => $requestMethodUpperCase,
            'request uri' => $requestUri,
            'matched uri' => $route['url'] ?? null,
            'matched method' => $routeMethods[0] ?? null,
            'url' => $url,
            'argv' => $argv,
            'argc' => count($argv),
            'args' => (bool)count($argv),
            'name' => $route['name'] ?? null,
            'callback' => $route['callback'] ?? null,
        ];

        logMsg('DEBUG', 'matched', $this->matched);

        return $this;
    }

    /**
     * Retrieves matched route information.
     *
     * @param string|null $key Specific key to retrieve (e.g., 'url', 'method').
     * @return mixed The value of the matched key or all matched data.
     * @throws InvalidValue If an invalid key is requested.
     */
    public function getMatched(string $key = null): mixed /* mixed string|array */
    {
        logMsg('DEBUG', __METHOD__, ['key' => $key]);

        if ($key != null && !\array_key_exists(strtolower($key), $this->matched)) {
            throw new InvalidValue('Unknown routing value "' . $key . '"');
        }

        return ($key) ? $this->matched[strtolower($key)] : $this->matched;
    }

    /**
     * Generates a URL from a named route and arguments.
     *
     * @param string $searchName Route name.
     * @param array $arguments Arguments for dynamic segments.
     * @return string The generated URL.
     * @throws RouterNameNotFound If the route name is not found.
     */
    public function getUrl(string $searchName, array $arguments = []): string
    {
        logMsg('INFO', __METHOD__ . ' ' . $searchName);
        logMsg('DEBUG', '', ['searchName' => $searchName, 'arguments' => $arguments]);

        $normalizedSearchName = $this->normalize($searchName);

        if (!isset($this->routesByName[$normalizedSearchName])) {
            throw new RouterNameNotFound($searchName);
        }

        $options = $this->routesByName[$normalizedSearchName];

        if (!isset($options['url'])) {
            throw new InvalidValue('missing "url" for route named ' . $searchName);
        }

        $matches = [];

        $this->matchedUrl = '';

        // merge the arguments with the available parameters
        if (preg_match_all('/\((.*?)\)/m', $options['url'], $matches, PREG_SET_ORDER, 0) !== false) {
            $this->matchedUrl = $this->processMatchedUrl($searchName, $arguments, $options['url'], $matches);
        }

        // if we are still empty then it's a complete fail
        if (empty($this->matchedUrl)) {
            throw new RouterNameNotFound($searchName);
        }

        logMsg('INFO', __METHOD__ . ' matched Url ' . $this->matchedUrl);

        return $this->matchedUrl;
    }

    /**
     * Generates the site's base URL, optionally with an HTTP/HTTPS prefix.
     *
     * This method allows the caller to:
     * - Include or exclude the HTTP/HTTPS prefix.
     * - Manually specify a custom prefix.
     *
     * @param bool|string $appendHttp
     *      - `true`: Automatically determines `http` or `https` based on the request.
     *      - `false`: Returns only the base URL without any protocol prefix.
     *      - `string`: Allows specifying a custom protocol prefix (e.g., `'ftp://'`).
     *
     * @return string The generated base URL with the specified prefix.
     */
    public function siteUrl(bool|string $appendHttp = true): string
    {
        logMsg('INFO', __METHOD__ . ' ' . $appendHttp);

        $prefix = '';

        if ($appendHttp === true) {
            $s = $this->input->isHttpsRequest() ? 's' : '';
            $prefix = ($appendHttp) ? 'http' . $s . '://' : '';
        } elseif (is_string($appendHttp)) {
            $prefix = $appendHttp;
        }

        $complete = $prefix . $this->siteUrl;

        logMsg('INFO', $complete);

        return $complete;
    }

    /**
     * Processes and generates a matched URL based on route arguments.
     *
     * This method replaces dynamic segments in a route URL with provided arguments,
     * ensuring they match expected patterns.
     *
     * @param string $searchName The name of the route being processed.
     * @param array $arguments An array of arguments to replace dynamic segments in the URL.
     * @param string $matchedUrl The base URL template containing dynamic placeholders.
     * @param array $matches Matches extracted from the URL pattern using regex.
     *
     * @return string The fully resolved and processed URL with arguments injected.
     * @throws InvalidValue If argument count mismatches the placeholders or regex validation fails.
     */
    protected function processMatchedUrl(string $searchName, array $arguments, string $matchedUrl, array $matches): string
    {
        logMsg('INFO', __METHOD__ . ' search ' . $searchName);
        logMsg('DEBUG', '', ['searchName' => $searchName, 'arguments' => $arguments, 'matchedUrl' => $matchedUrl, 'matches' => $matches]);

        $matchesCount = count($matches);

        if (count($arguments) != $matchesCount) {
            throw new InvalidValue('Parameter count mismatch. Expecting ' . $matchesCount . ' got ' . count($arguments) . ' route named "' . $searchName . '".');
        }

        if ($matchesCount > 0) {
            foreach ($matches as $index => $match) {
                $value = (string)$arguments[$index];

                // make sure the argument matches the regular expression for that segement
                if (!$this->getUrlSkip && !preg_match('@' . $match[0] . '@m', $value)) {
                    throw new InvalidValue('Parameter mismatch. Expecting ' . $match[1] . ' got ' . $value . ' route named "' . $searchName . '".');
                }

                // replace the segement with the passed argument
                $matchedUrl = preg_replace('/' . preg_quote($match[0], '/') . '/', $value, $matchedUrl, 1);
            }
        }

        logMsg('INFO', __METHOD__ . ' match ' . $matchedUrl);

        return $matchedUrl;
    }
}
